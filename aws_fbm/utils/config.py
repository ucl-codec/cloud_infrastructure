from aws_fbm.utils.utils import repo_path

from dataclasses import dataclass, fields, field, InitVar
from typing import List, Type, Optional
from configparser import ConfigParser, SectionProxy, RawConfigParser
import os


@dataclass
class NetworkConfig:
    """Configuration for a Federated network

    The configuration is stored in a config file e.g. config/dev.cfg
    which is automatically parsed to create an object of this class
    """

    # Name of the config file used to generate this instance. This will be used
    # to construct resource names which need to be unique across the AWS account
    config_name: InitVar[str]

    # Always "network"
    node_name: str

    # Human-readable name of the Researcher site
    site_description: str

    # Domain used when connected to the Researcher VPN
    domain_name: str

    # Optional: if specified, will override the main stack name. If not set,
    # a default stack name will be created
    stack_name: Optional[str] = None  # If specified, overrides the stack name

    # Autogenerated name of parameter storing ARN of the VPN server certificate
    param_vpn_cert_arn: str = field(init=False)

    # Autogenerated name of parameter storing ARN of the VPN endpoint ID
    param_vpn_endpoint_id: str = field(init=False)

    def __post_init__(self, config_name: str):
        self.name_prefix = f"passianfl-{config_name}-{self.node_name}"
        self.param_vpn_cert_arn = f"{self.name_prefix}-vpn-server-cert-arn"
        self.param_vpn_endpoint_id = f"{self.name_prefix}-vpn-endpoint-id"


@dataclass
class NodeConfig:
    """Configuration for a Data Node

    The configuration is stored in a config file e.g. config/dev.cfg
    which is automatically parsed to create an object of this class
    """

    # Name of the config file used to generate this instance. This will be used
    # to construct resource names which need to be unique across the AWS account
    config_name: InitVar[str]

    # Name of node, from the section name in the config file
    node_name: str

    # Human-readable name of the Data Node site
    site_description: str

    # Domain used when connected to the Data Node VPN
    domain_name: str

    # Persistent data bucket for this Data Node
    bucket_name: str

    # FBM default gui admin username
    default_gui_username: str

    # True if Fed-BioMed should require training plans to be approved
    enable_training_plan_approval: bool = True

    # True if FBM should allow default training plans
    allow_default_training_plans: bool = False

    # True if FBM GUI should use the gunicorn production webserver
    use_production_gui: bool = True

    # Optional: if specified, will override the main stack name. If not set,
    # a default stack name will be created
    stack_name: Optional[str] = None  # If specified, overrides the stack name

    # Autogenerated name of S3 bucket to be used for data import
    import_bucket_name: str = field(init=False)

    # Autogenerated name prefix of secret storing FBM gui default admin password
    secret_name_default_gui_password: str = field(init=False)

    # Autogenerated name of parameter storing ARN of the VPN server certificate
    param_vpn_cert_arn: str = field(init=False)

    # Autogenerated name of parameter storing ARN of the VPN endpoint ID
    param_vpn_endpoint_id: str = field(init=False)

    def __post_init__(self, config_name: str):
        self.name_prefix = f"passianfl-{config_name}-{self.node_name}"
        self.import_bucket_name = f"{self.name_prefix}-import-bucket"
        self.param_vpn_cert_arn = f"{self.name_prefix}-vpn-server-cert-arn"
        self.param_vpn_endpoint_id = f"{self.name_prefix}-vpn-endpoint-id"
        self.secret_name_default_gui_password = \
            f"{self.name_prefix}-gui-default-admin-password"


@dataclass
class Config:
    """Configuration for a PassianFL system

    The configuration is stored in a config file e.g. config/dev.cfg
    which is automatically parsed to create an object of this class
    """
    network: NetworkConfig  # Configuration for the Federated network
    nodes: List[NodeConfig]  # Configuration for Data Nodes


def read_config_file(config_name: str) -> Config:
    """Read config file from config folder and parse to Config class"""
    if not config_name:
        raise RuntimeError("A config (prod or dev) must be specified, e.g. "
                           "cdk --context config=dev")
    config_filename = repo_path() / "config" / config_name
    config_filename = config_filename.with_suffix(".cfg")
    if not os.path.isfile(config_filename):
        raise RuntimeError(f"Unknown config {config_filename} was specified")

    config = RawConfigParser()
    config.read(config_filename)
    return parse_config(config_name=config_name, config=config)


def parse_config(config_name: str, config: ConfigParser):
    """Convert returned config structure to Config object"""
    network_section = "network"
    return Config(
        network=convert_inputs(
            dataclass_type=NetworkConfig,
            section=config[network_section],
            config_name=config_name,
            node_name="network"),
        nodes=[convert_inputs(
            dataclass_type=NodeConfig,
            section=config[section],
            config_name=config_name,
            node_name=section) for
               section in config.sections() if section != network_section]
    )


def convert_inputs(dataclass_type: Type, section: SectionProxy, **kwargs):
    """Convert this config section into a dataclas object, converting the string
    variables where necessary"""
    field_types = {field.name: field.type for field in fields(dataclass_type)}
    converted = {
        key: convert_to(section=section,
                        key=key,
                        field_type=field_types[key]) for key in section
    }
    return dataclass_type(**converted, **kwargs)


def convert_to(section: SectionProxy, key: str, field_type: Type):
    """Fetch the given key from the config section, converting to the specified
    type if required"""
    return section.getboolean(key) if field_type == bool else section.get(key)

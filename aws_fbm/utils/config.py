from aws_fbm.utils.utils import repo_path

from dataclasses import dataclass, fields, field, InitVar
from typing import List, Type, Optional
from configparser import ConfigParser, SectionProxy, RawConfigParser
import os


@dataclass
class NetworkConfig:
    """Configuration for a Federated network

    The configuration is stored in a config file e.g. config/dev.cfg
    which is automatically parsed to create an object of this class
    """

    # Name of the config file used to generate this instance. This will be used
    # to construct resource names which need to be unique across the AWS account
    config_name: InitVar[str]

    # Always "network"
    node_name: str

    # Human-readable name of the Researcher site
    site_description: str

    # Domain used when connected to the Researcher VPN
    domain_name: str

    # Whether to use TLS-encrypted https traffic to the web services.
    # Even though all traffic is tunneled through the VPN, it is still
    # recommended that you set this to True for production systems.
    # If True, you must set the parent_domain parameter and create a
    # corresponding public hosted zone for a domain name you control. You must
    # set the NS records on your registrar to point to the public hosted zone in
    # order for certificate validation to succeed
    use_https: bool = True

    # Domain of an existing AWS public hosted zone in this account. You must
    # create this public hosted zone yourself. This should generally be the
    # parent of the domain_name (e.g. if domain_name is
    # researcher.example.com, parent_name should normally be example.com).
    # This setting is required when using https certificates. A public hosted
    # zone will be created for the domain_name and its NS records will be added
    # to the existing public hosted zone for the parent_domain.
    # For https certificate validation to work, you must also add the NS records
    # for the parent public hosted zone you created to the DNS provider of the
    # parent domain.
    parent_domain: Optional[str] = None

    # Optional: if specified, will override the prefix used to construct stack
    # names
    name_prefix: Optional[str] = None

    # Optional: if specified, will override the main stack name. If not set,
    # a default stack name will be created
    stack_name: Optional[str] = None

    # Autogenerated name of parameter storing ARN of the VPN server certificate
    param_vpn_cert_arn: str = field(init=False)

    # Autogenerated name of parameter storing ARN of the VPN endpoint ID
    param_vpn_endpoint_id: str = field(init=False)

    def __post_init__(self, config_name: str):
        self.prefix = f"passianfl-{config_name}-{self.node_name}"
        if not self.name_prefix:
            self.name_prefix = f"{self.prefix}-"
        self.param_vpn_cert_arn = f"{self.prefix}-vpn-server-cert-arn"
        self.param_vpn_endpoint_id = f"{self.prefix}-vpn-endpoint-id"


@dataclass
class NodeConfig:
    """Configuration for a Data Node

    The configuration is stored in a config file e.g. config/dev.cfg
    which is automatically parsed to create an object of this class
    """

    # Name of the config file used to generate this instance. This will be used
    # to construct resource names which need to be unique across the AWS account
    config_name: InitVar[str]

    # Name of node, from the section name in the config file
    node_name: str

    # Human-readable name of the Data Node site
    site_description: str

    # Domain used when connected to the Data Node VPN
    domain_name: str

    # FBM default gui admin username
    default_gui_username: str

    # Whether to use TLS-encrypted https traffic to the web services.
    # Even though all traffic is tunneled through the VPN, it is still
    # recommended that you set this to True for production systems.
    # If True, you must set the parent_domain parameter and create a
    # corresponding public hosted zone for a domain name you control. You must
    # set the NS records on your registrar to point to the public hosted zone in
    # order for certificate validation to succeed
    use_https: bool = True

    # Domain of an existing AWS public hosted zone in this account. You must
    # create this public hosted zone yourself. This should generally be the
    # parent of the domain_name (e.g. if domain_name is
    # researcher.example.com, parent_name should normally be example.com).
    # This setting is required when using https certificates. A public hosted
    # zone will be created for the domain_name and its NS records will be added
    # to the existing public hosted zone for the parent_domain.
    # For https certificate validation to work, you must also add the NS records
    # for the parent public hosted zone you created to the DNS provider of the
    # parent domain.
    parent_domain: Optional[str] = None

    # True if Fed-BioMed should require training plans to be approved
    enable_training_plan_approval: bool = True

    # True if FBM should allow default training plans
    allow_default_training_plans: bool = False

    # True if FBM GUI should use the gunicorn production webserver
    use_production_gui: bool = True

    # Optional: if specified, will override the prefix used to construct stack
    # names
    name_prefix: Optional[str] = None

    # Optional: if specified, will override the main stack name. If not set,
    # a default stack name will be created
    stack_name: Optional[str] = None  # If specified, overrides the stack name

    # Autogenerated name of S3 bucket to be used for data import
    import_bucket_name: str = field(init=False)

    # Autogenerated name prefix of secret storing FBM gui default admin password
    secret_name_default_gui_password: str = field(init=False)

    # Autogenerated name of parameter storing ARN of the VPN server certificate
    param_vpn_cert_arn: str = field(init=False)

    # Autogenerated name of parameter storing ARN of the VPN endpoint ID
    param_vpn_endpoint_id: str = field(init=False)

    def __post_init__(self, config_name: str):
        self.prefix = f"passianfl-{config_name}-{self.node_name}"
        if not self.name_prefix:
            self.name_prefix = f"{self.prefix}-"
        self.import_bucket_name = f"{self.prefix}-import-bucket"
        self.param_vpn_cert_arn = f"{self.prefix}-vpn-server-cert-arn"
        self.param_vpn_endpoint_id = f"{self.prefix}-vpn-endpoint-id"
        self.secret_name_default_gui_password = \
            f"{self.prefix}-gui-default-admin-password"


@dataclass
class Config:
    """Configuration for a PassianFL system

    The configuration is stored in a config file e.g. config/dev.cfg
    which is automatically parsed to create an object of this class
    """
    network: NetworkConfig  # Configuration for the Federated network
    nodes: List[NodeConfig]  # Configuration for Data Nodes


def read_config_file(config_name: str) -> Config:
    """Read config file from config folder and parse to Config class"""
    if not config_name:
        raise RuntimeError("A config (prod or dev) must be specified, e.g. "
                           "cdk --context config=dev")
    config_filename = repo_path() / "config" / config_name
    config_filename = config_filename.with_suffix(".cfg")
    if not os.path.isfile(config_filename):
        raise RuntimeError(f"Unknown config {config_filename} was specified")

    config = RawConfigParser()
    config.read(config_filename)
    return parse_config(config_name=config_name, config=config)


def parse_config(config_name: str, config: ConfigParser):
    """Convert returned config structure to Config object"""
    network_section = "network"
    return Config(
        network=convert_inputs(
            dataclass_type=NetworkConfig,
            section=config[network_section],
            config_name=config_name,
            node_name="network"),
        nodes=[convert_inputs(
            dataclass_type=NodeConfig,
            section=config[section],
            config_name=config_name,
            node_name=section) for
               section in config.sections() if section != network_section]
    )


def convert_inputs(dataclass_type: Type, section: SectionProxy, **kwargs):
    """Convert this config section into a dataclas object, converting the string
    variables where necessary"""
    field_types = {field.name: field.type for field in fields(dataclass_type)}
    converted = {
        key: convert_to(section=section,
                        key=key,
                        field_type=field_types[key]) for key in section
    }
    return dataclass_type(**converted, **kwargs)


def convert_to(section: SectionProxy, key: str, field_type: Type):
    """Fetch the given key from the config section, converting to the specified
    type if required"""
    return section.getboolean(key) if field_type == bool else section.get(key)
